# RYVM
A register-based process virtual machine and assembler. It can compile human-readable RYVM Assembly code into RYVM bytecode that can be run by the virtual machine.

> Note that this project is still in development and the instruction set is prone to change. 
> Don't use this project in a production environment. 

## TODO List
- Fully implement the FPFX and FXFP instructions.
- Add semantic checks in assembler to prevent using 8-bit or 16-bit register widths with floating point operations, since they currently only support 32-bit and 64-bit floating point numbers.
- Add support for dynamic memory allocations.
- Define a default calling convention for subroutines and syscalls.
- Add support for 16-bit IEEE 754 floating point calculations without depending on compiler extensions.
- Find a 8-bit floating point standard (minifloat).
- Allow two or more compiled RYVM bytecode files to be linked into one RYVM executable.
- Allow programmers to configure a RYVM executable a "debug mode", where the VM can perform
  memory bounds-checking and print debug information when encountering an error that would normally
  crash the program (such as attempting to access out-of-bounds memory or executing an invalid opcode).
- Allow programmers to compile RYVM executable files into native assembly or machine code and store it
  in the appropriate executable format (ELF for Linux, MachO for MacOS, PE for Windows).

## Building the Project
This project was written using standard C99. No compiler extensions or platform-specific APIs
are used in this project, so this should work on MacOS, Linux, and Windows.

You can build and run the project using Make. While its mostly used in Unix-based OSs, there
are versions available for Windows, or you can use the Windows Subsystem for Linux to install 
and use Make.

There are 2 executables generated from this project: 
  - The RYVM Assembler (stored in generated_bins/ryasm)
  - The RYVM VM (stored in generated_bins/ryvm)


Use `make` or `make release` to build both executables in release mode.

Use `make debug` to build both executables in debug mode.

Use `make build_asm` to only build the RYVM Assembler in release mode.

Use `make build_vm` to only build the RYVM VM in release mode.

Use `make run_sample` to compile a sample RYVM Assembly file to a RYVM bytecode file, then have the VM run the bytecode from that file.

Use `make run_asm_sample` to compile a sample RYVM Assembly file to a RYVM bytecode file.

Use `make run_vm_sample` to have the VM run the bytecode from the output file previously written to by `make run_asm_sample`.

Use `make clean` to clean up all generated executables and object files.


### About the Executables

#### RYVM Assembler
Located at generated_bins/ryasm, the assembler takes in 2 arguments: a input file path and an output file path.
The input file should contain RYVM Assembly source code, which will be compiled into bytecode. This bytecode is
stored in the output file.

Example Usage:
```
# The below will compile the source code at the file path in the 1st argument, then
# output the generated bytecode to the file path in the 2nd argument.
./generated_bins/ryasm ./tests/programs/arith.ryasm ./tests/programs/arith.ryasm.ryc
```

#### RYVM VM
Located at generated_bins/ryvm, the VM takes in 1 argument: a path to a file containing compiled RYVM bytecode. The
VM will execute the bytecode.

Example Usage:
```
# run the RYVM bytecode stored in the 1st argument
./generated_bins/ryvm ./tests/programs/arith.ryasm.ryc
```


## Overview
Here is a general overview of the RYVM virtual machine:

- RYVM is a 64-bit process virtual machine. It assumes all addresses are 64-bits and can store
  up to 64 bits in each of its registers.

### General Definitions
First, we will cover some terminology and definitions:
- A bit is a binary value (0 or 1)
- A byte is defined as 8 bits.
- A word is defined as 8 bytes.
- Bytecode is the binary instruction set that a virtual machine can understand and execute. 
- RYVM is a bytecode interpreter that interprets bytecode and executes the appropriate native code
  for that bytecode.
- RYVM programs can be handwritten using RYVM Assembly, a human-readable format for RYVM bytecode.
  - There programs can be stored in .ryasm files.
- RYVM Assembly files can be compiled into RYVM executable files (under the .ryc extension), which contain raw binary bytecode that the VM can execute.


### Registers
- There are 64 registers, each of which can hold a 64-bit word.
- You can access a register using an index of 0 through 63.
- Each register has a 8-bit, 16-bit, 32-bit, and 64-bit view.
  - E0 accesses the least significant byte of register 0.
  - Q1 accesses the 2 least significant bytes of register 1.
  - H10 accesses the 4 least significant bytes of register 10.
  - W25 accesses the full 8 byte value of register 25.

- Here is a diagram regarding what bytes are processed when 
  using the E, Q, H, and W sigils for registers:

```
Register Bytewidth | Least Significant Bytes                        Most Significant Bytes
  E (eigth word)   |-Byte 1-| 
  Q (quarter word) |-Byte 1-|-Byte 2-|
  H (half word)    |-Byte 1-|-Byte 2-|-Byte 3-|-Byte 4-|
  W (whole word)   |-Byte 1-|-Byte 2-|-Byte 3-|-Byte 4-|-Byte 5-|-Byte 6-|-Byte 7-|-Byte 8-|
```

- There are 59 general purpose registers (W0-W59). These store 64 bits of memory, which can
  be used to store 64-bit memory addresses, 32-bit and 64-bit floating-point numbers, signed and unsigned integers, fixed-point numbers, and any other data that can fit within 64 bits.

- There are currently five special registers:
  - PC 
    - The program counter. Stores the address of the NEXT instruction to execute.
      - This does not store the address of the currently executing instruction.
    - Is a alias of register W63
  - SP 
    - The stack pointer. Stores the address to the top of the VM's stack.
    - Is a alias of register W62
  - FP 
    - The frame pointer. Stores the value of the stack pointer the moment before a subroutine call is made.
    - Is a alias of register W61
  - LR
    - The link register. Used to store the return address of the caller code before entering a subroutine.
    - Is an alias of register W60
  - SF
    - The status register. Stores some flags relating to the state of the VM.
    - Is an alias of register W59
    - There are currently 3 flags being tracked:
      - N
        - Negative (or sign) bit.
        - Set to 1 if the result of a comparison is negative, otherwise set to 0.
      - V
        - Overflow bit.
        - Set to 1 if a overflow/underflow occurs during a comparison, otherwise set to 0.
        - Unlike other instruction sets, this bit can be set from either a signed overflow or a unsigned overflow.
      - Z
        - Zero bit.
        - Set to 1 if the result of a comparison is zero, otherwise set to 1.

    - These flags get set during:
      - Signed Integer Comparisons
      - Unsigned Integer Comparisons
      - Floating Point Number Comparisons


- Despite W59-W63 being "special" registers, you can still manipulate them like any other register.
  Just be warned that modifying their values may cause issues if you don't know the purpose of those
  registers.

### Stack
The RYVM virtual machine has a stack, whose size can be configured by the programmer of the RYVM
assembler file. Note that the stack does not grow at runtime, so the programmer must ensure that
the stack pointer never goes out-of-bounds.

### Memory Safety (or lack thereof)
- There are currently no checks to ensure memory safety, so if the stack overflows or the PC
  tries to execute instructions outside the .text section, undefined behavior will occur and 
  likely cause the VM to crash.
- I hope to change this in the future by allowing the option for the programmer to configure the VM
  to perform automatic memory safety checks.




## RYVM Assembly Instruction Set
There are currently 44 different instructions. All instructions are 4 bytes long. All instructions start with a 1-byte opcode.


### Formats
There are 4 formats that the instruction set can take: R0, R1, R2, and R3.

#### R0
> 0 register arguments, 1 24-bit immediate argument

The first byte is the opcode, and the other 3 bytes store a single
24-bit immediate value.

```
Bits:  31-24         23-0
  |-- Opcode --|-- 24-bit immediate value --| 
```

#### R1
> 1 register argument, 1 16-bit immediate value

The first byte is the opcode, the 2nd byte is the register and it's bytewidth, and the 3rd and 4th bytes represent a 16-bit immediate value.

```
Bits:  31-24              23-16                       15-0
  |-- Opcode --|-- Destination Register --|-- 16-bit immediate value --| 
```

#### R2
> 2 register arguments, 1 8-bit immediate value

The first byte is the opcode, the 2nd byte is the destination register, the 3rd byte is the source register, and the 4th byte represents a 8-bit immediate value.

```
Bits:  31-24              23-16                    15-8                       7-0
  |-- Opcode --|-- Destination Register --|-- Source Register --|-- 8-bit immediate value --| 
```

#### R3
> 3 register arguments, 0 immediate values

The first byte is the opcode, the 2nd byte is the destination register, the 3rd byte is the 1st source register, and the 4th byte represents the 2nd source register

```
Bits:  31-24              23-16                       15-8                       7-0
  |-- Opcode --|-- Destination Register --|-- 1st Source Register --|-- 2nd Source Register --| 
```

### Mnemonics
Note that there are no pseudo-instructions; Each mnemonic directly corresponds to a opcode inside RYVM.
Also, in the below list:
  - `imm` is a placeholder for an immediate value, which is any signed or unsigned integer literal or a label expression.
  - `;` is the start of a comment about the mnemonic.

Here is the current list of mnemonics that correspond to each opcode for RYVM:

```
LDA E0 W1 imm         ; Load from address at (W1 + imm) and put the 8 bits into E0
PCR W0 imm            ; Get PC-relative address using a 2-byte signed offset and store it in W0
LDI W0 imm            ; load 2-byte immediate value that's sign-extended to the specified byte-width. Can only be integers.
STR E0 W1 imm         ; Store E0 into address stored at (W1 + imm)
FXFP W0 W1 imm        ; Convert fixed point to floating point. W0 = (float) W1; where imm[0] determines if W1 is signed or unsigned, and imm[1:7] is the 7-bit number representing the number of fractional bits in W1 
FPFX W0 W1 imm        ; Convert floating point to fixed point. W0 = imm & 0b10000000 == 0 ? (unsigned int) W1 : int(W1); where imm[0] determines if W0 is signed or unsigned, and imm[1:7] is the 7-bit number representing the number of fractional bits in W0 
ADDI W0 W1 imm        ; W1 + imm = W0 ; imm is signed 8 bits
SUBI W0 W1 imm        ; W1 - imm = W0 ; imm is signed 8 bits
ADD E0 E1 E2          ; Add 8bit 2-s complement integers and store it in E0
SUB E0 E1 E2          ; Subtract 8bit 2-s complement integers and store it in E0
MUL E0 E1 E2          ; multiply 2 signed integers 
MULU E0 E1 E2         ; multiply 2 unsigned integers 
DIV E0 E1 E2          ; divide 2 signed integers 
DIVU E0 E1 E2         ; divide 2 unsigned integers 
REM E0 E1 E2          ; remainder 2 signed integers 
REMU E0 E1 E2         ; remainder 2 unsigned integers 
ADDF W0 W1 W2         ; Add 64bit floating point and store it in W0
SUBF W0 W1 W2         ; Subtract 64bit floating point and store it in W0
MULF W0 W1 W2         ; Multiply 64bit floating point and store it in W0
DIVF W0 W1 W2         ; Divide 64bit floating point and store it in W0
REMF W0 W1 W2         ; Remainder 64bit floating point and store it in W0
AND W0 W1 W2          ; bitwise AND operation
OR W0 W1 W2           ; bitwise OR operation
XOR W0 W1 W2          ; bitwise XOR operation
XORI W0 W1 imm        ; bitwise XOR operation with immediate 8bit value sign extended to bytewidth of source register
SHL W0 W1 W2          ; bitwise shift left
SHR W0 W1 W2          ; bitwise shift right
BIC E0 E1 E2          ; if bit at E2 is 0, keep bit at E1. If bit at E2 is 1, clear bit in E1 to 0. Store result in E0
CPS W0 W1 W2          ; Signed comparison; Similar to SUB, except SF flags register is updated (specifically the N,Z, and V flags)
CPU W0 W1 W2          ; Unsigned comparison; Similar to SUB, except SF flags register is updated (specifically the N,Z, and V flags)
CPF W0 W1 W2          ; Floating point comparison; Similar to SUBF, except SF flags register is updated (specifically the N,Z, and V flags)
CPSI W0 imm           ; Signed comparison to 16-bit immediate; Result is discarded, and SF flags register is updated (specifically the N,Z, and V flags)
CPUI W0 imm           ; Unsigned comparison to 16-bit immediate; Result is discarded, and SF flags register is updated (specifically the N,Z, and V flags)
B imm                 ; unconditional jump to signed 24-bit PC-relative offset
BEQ imm               ; Check status register flags (Z=1) if previous comparison (CPS, CPU, CPF) states that both operands were equal, if this is true, jump to PC-relative offset.
BNE imm               ; Check status register flags (Z=0) if previous comparison (CPS, CPU, CPF) states that both operands were not equal, if this is true, jump to PC-relative offset.
BLT imm               ; Check status register flags (N!=V) if previous comparison (CPS, CPU, CPF) states that operand1 < operand2, if this is true, jump to PC-relative offset.
BGT imm               ; Check status register flags (N=V and Z=0) if previous comparison (CPS, CPU, CPF) states that operand1 > operand2, if this is true, jump to PC-relative offset.
BLE imm               ; Check status register flags (N!=V or Z=1) if previous comparison (CPS, CPU, CPF) states that operand1 <= operand2, if this is true, jump to PC-relative offset.
BGE imm               ; Check status register flags (N=V or Z=1) if previous comparison (CPS, CPU, CPF) states that operand1 >= operand2, if this is true, jump to PC-relative offset.
BR W0 imm             ; pc = W0 + imm;  indirect jump without saving link register. can be useful for return statement or for executing a specific function within an array of function pointers.
BL W0 imm             ; branch and link; W0 = pc + 4; pc = pc + imm  ; imm is signed 16bit offset
BLR W0 W1 imm         ; W0 = pc + 4;   pc = W1 + imm ; imm is signed 8bits (used for indirect jumps, calls, and returns)
SYS imm                ; a external function call to call OS-specific functions in a cross-platform way, using a 24bit syscall number 

```

## RYVM Assembly Syntax.
If you want examples of the current syntax of RYVM Assembly, look at the test/programs directory and check the .ryasm files. Here's a summary of the syntax:


### RYVM Assembly Grammer (BNF)
In the below grammer:
- Non-Terminals are enclosed in angle brackets <>
- String Literals are enclosed in ' ' or  " "
- Empty string is ""
- Uppercase words are terminals that represent a category of literals. 
  - ASCII represents the set of all 128 ASCII character literals
  - NON_WHITESPACE_ASCII represents the set of all ASCII characters excluding whitespace characters (spaces, tabs, newlines, carriage returns, etc)
  - MNEMONICS represents all of the current mnemonics listed in the Mnemonics section of this README.
  - NEWLINE represents the newline character, ususally denoted by '\n' (or ASCII character 10)

- Note that no rule was specified for single line comments, though they are allowed in RYVM Assembly files.

```
  <Prog> ::= <Config> <LF> <Data> <LF> <Text>

  <Config> ::= <MaxStackSize> <Integer>


  <Data> ::= '.data' <LF> <DataBody>
  <DataBody> ::=  ("" | <LabelDef>) <DataEntry> ("" | <LF> <DataBody>)
  <DataEntry> ::= <DataRawByteEntry> | <AsciiEntry>
  <AsciiEntry> ::= '.asciz' WS <StringLiteral>
  <DataRawByteEntry> ::= '.eword' <WS> <ListOfStringsAndInts>
  | '.qword' <WS> <ListOfInts>
  | '.hword' <WS> <ListOfFloatsAndInts>
  |  '.word' <WS> <ListofFloatsAndInts>

  <ListOfStringsAndInts> ::= (<StringLiteral> | <IntExpr>) ("" | <WS> <ListOfStringsAndInts>)
  <ListOfFloatsAndInts> ::= (<Float> | <IntExpr>) ("" | <WS> <ListOfFloatsAndInts>) 
  <ListOfInts> ::= <IntExpr> ("" | <WS> <ListOfInts>)


  <Text> ::= '.text' <LF> <TextBody>
  <TextBody> ::= ("" | <LabelDef>) (<Instruction> | <DataEntry>) <LF> ("" | <TextBody>)  

  <Instruction> ::= <InstructionR0> | <InstructionR1>  | <InstructionR2> | <InstructionR3>

  <InstructionR0> ::= <Mnemonic> <WS> <IntExpr>
  <InstructionR1> ::= <Mnemonic> <WS> <Register> <WS> <IntExpr>
  <InstructionR2> ::= <Mnemonic> <WS> <Register> <WS> <Register> <IntExpr>
  <InstructionR3> ::= <Mnemonic> <WS> <Register> <WS> <Register> <WS> <IntExpr>


  <Mnemonic> ::= MNEMONICS
  <Register> ::= ('E' | 'Q' | 'H' | 'W') <Digit> ("" | <Digit>)

  <StringLiteral> ::= '"' <AsciiList> '"'
  <AsciiList> ::= <AsciiChar> ("" | <AsciiList>)
  <AsciiChar> ::= ASCII

  <IntExpr> ::= <SignedInteger> | <LabelExpr>

  <LabelExpr> ::= ('@' | '#') <Label>
  <LabelDef> ::= ':' <Label>
  <Label> ::= NON_WHITESPACE_ASCII ("" | <Label>)

  <Float> ::= <Integer> '.' <Integer>
  <SignedInteger> ::= ("" | '-') <Integer>
  <Integer> ::= <Digit> ("" | <Integer>)

  <Letter> ::= 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm'
       | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
       | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M'
       | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'


  <Digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  <WS> ::= ' '  ("" | <WS>)
  <LF> ::= NEWLINE

```

### Comments
RYVM Assembly uses the ';' character to specify a single line comment. The comment terminates
once it reaches the newline character. There are no block comments.
```
; Here is a comment 
LDI W0 10  ; here is a comment after an instruction

```


### Configuration
All RYVM Assembly files start with setting the configuration of the VM. Here are the current configuration options.
- .max_stack_size |num_bytes| 
  - This tells the VM how many bytes to allocate for the stack when executing this program.
  - You must use a non-negative integer literal for the |num_bytes| placeholder.
  

### .data section
After this, you can include an optional .data section to list all global data for the executable. 

#### Data Entry Types
Here are the following allowed data types:
- .eword
  - Specifies the start of a list of 8-bit integer values. You can use positive or negative integer
    literals here. You can also list string literals, though do note that the null character of the string literal will not be included in the data entry.
- .qword
  - Specifies the start of a list of 16-bit integer values. You can use positive or negative integer
    literals here.
- .hword
  - Specifies the start of a list of 32-bit integer values. You can use positive or negative integer
    literals here as well as floating point literals.
- .word
  - Specifies the start of a list of 64-bit integer values. You can use positive or negative integer
    literals here as well as floating point literals. You can also insert the address of a label using the @label syntax, which inserts the 64-bit relative address of the label.
- .asciz
  - Specifies a single ASCII string literal to insert, automatically appending the null character (\0)
    at the end of the string.

### .text section

After the .data section, you will insert a .text section, which contains the actual bytecode that
will run on the VM. Here, you can insert both instructions and data entries. Each instruction
contains a mnemonic followed by 1-3 arguments, which can either be registers or immediate values.

Example:
```
.text

; Instructions
LDI W0 10  ;load immediate signed value 10 into W0
LDI W1 5  ;load immediate signed value 10 into W0

ADD W2 W0 W1 ; W2 = W0 + W1 = 10 + 5 = 15

ADDI W2 W2 5 ; W2 = W2 + 5 = 15 + 5 = 20  

B #end_literal_pool  ;jump over literal pool data entries to avoid executing them.

;literal pools can be used to store memory addresses that cannot be reached by a PC-relative offset.
.word 8
.word 10
.asciz "Hi there"

:end_literal_pool

SYS 0  ; a syscall with 24-bit immediate value 0. This exits the VM.
```

### Labels
You can label instructions or data entries using the :label syntax. Each label represents a specific address within the RYVM code and data section. All label definitions start
with the ':' sigil and can be followed by any non-whitespace ASCII characters.
  - :begin
  - :1
  - :Hi_There_1

Note that you must follow a label by either an instruction or data entry.

 
### Label Expressions
Labels are useless without the ability to actually use them as expressions for immediate values
or literals within instructions or data entries.
There are 2 different ways to use a label as a expression for where immediate values or literals
would normally go.

1. Signed PC-relative Offsets (#label)
  - You can use the '#' sigil before a label name to specify that you want to insert a signed PC-relative offset at a specific instruction or data entry. 
  
  - Example
    ```
    .max_stack_size 0
    .data
    :data_entry_1 .word 8

    .text
    ;if we want to load the 8-byte value at :data_entry_1, we need to retrieve its offset
    ;from the PC and get its address.

    ;We can do this by using #data_entry_1, which will insert the PC-relative offset of :data_entry_1.
    ;Because the PCR instruction expects a 16-bit signed integer, the value of
    ; #data_entry_1 will be a 16-bit signed offset.

    PCR W0 #data_entry_1 ; get the signed PC-relative offset, add it to the PC, and store it in W0
    
    ; The above instruction gets converted to PCR W0 -12, since the start of :data_entry_1 is 
    ; -12 bytes away from the current PC. The PCR instruction will then add PC to -12 and store
    ; the result in W0
    
    ; Now W0 contains the result of PC + (PC-relative offset)

    LDA W0 W0 0  ; load address in W0 + 0 and store the value 8 in W0.

    ; Now W0 contains 8.

    ```

2. Address of Label (@label)
  - You can use the '@' sigil before a label name to specify that you want to insert the full
    8-byte address of the label.
  - Note that you should use the PC-relative offsets most of the time. However, depending on the instruction, you may only be able to store that offset in a 8-bit, 16-bit, or 24-bit value. If
  the offset is too large to fit in those values, the program will crash. 
    - By using the @label syntax, you can insert a literal pool near the instruction that needs
      the out-of-range address and make that instruction perform a PC-relative load to retrieve that
      address.
  - Example
    ```
    .max_stack_size 0
    .text

    ; note that you can insert data entries inside .text sections to create literal pools.
    ; However, you must ensure you jump over those literal pools to avoid executing them
    ; as actual code. This is similar to how ARM64 handles literal pools.

    B #begin   ; jump over literal pool to the :begin label.

    :func_adr .word @func   ;store :func full address in literal pool entry.

    :begin

    LDI W1 10 ; load immediate value 10 into W0
    
    PCR W0 #func_adr  ; get PC-relative offset of literal pool entry containing the :func address.
    LDA W0 W0 0       ;load the address of :func into W0
    
    BLR LR W0 0       ; branch to the address W0 + 0, storing the return address in LR.
    SYS 0             ; exit the VM


    :func
      ADDI W0 W1 8 ; add 8 to W1 and store it in W0
      BLR LR 0     ; return to address stored in link register


    ```


## RYVM Executable Format
Due to this project being a work-in-progress, the format of the RYVM executable is rapidly changing
and has no documentation. Assume that a RYVM executable you compiled in a previous version of
RYVM will not work on a newer version.

Once I finish all of the main features of the VM, I will document the file format for the RYVM Executable.

## Similar Projects
- Java Virtual Machine
- Lua virtual machine